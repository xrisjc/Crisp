///////////////////////////////////////////////////////////////////////////////
// File: Test.crisp
// Purpose: Integration testing of Crisp functionality that also serves as a
// guide to Crisp (for now).
///////////////////////////////////////////////////////////////////////////////

//
// As you might have guessed, // starts a comment.  As per usual, comments are
// ignored and end when a new line character is reached.
//
// All other whitespace is ignored, so your free to format code as you see
// fit.
//

//
// Crisp is a dynamic language with Pascal-like syntax where everything is
// an expression and all values are objects.
//

///////////////////////////////////////////////////////////////////////////////
// Basic Literals
///////////////////////////////////////////////////////////////////////////////

var testLiterals := function (t) begin
    // Crisp has the literal expressions you would expect.

    // Strings are delimited by single quotes. The are the .NET string type
    // internally.
    t.assertEq('hi', 'hi', 'string literal')

    // Number values are 64 bit floating point numbers.
    t.assertEq(123, 123, 'integer number literal')
    t.assertEq(1.5, 1.5, 'fractional number literal')

    // Boolean values are given by keywords true and false representing the
    // obvious values.  The are represented by the bool type internally.
    t.assert(true, 'true literal')
    t.assertEq(false, false, 'false literal')

    // The keyword null evaluates to the null object value, which is a singleton
    // value that is not equal to any other value.
    t.assertEq(null, null, 'null literal')
end

///////////////////////////////////////////////////////////////////////////////
// Operators
///////////////////////////////////////////////////////////////////////////////

var testOperators := function (t) begin
    // After literals, more complex expressions can be created with operators.

    // Crisp has the usual arithmetic operators `+`, `-`, `*`, `/`, and `mod`.
    t.assertEq(1.0 + 2.5,  3.5, 'addition')
    t.assertEq(5.5 - 2.0,  3.5, 'subtraction')
    t.assertEq(2.5 * 3.0,  7.5, 'multiplication')
    t.assertEq(12.5 mod 5.0, 2.5, 'modulo')
    t.assertEq(15.0 / 5.0, 3.0, 'division #1')
    t.assertEq(1.0 / 2.0,  0.5, 'division #2')
    t.assertEq(-0.5, 0.5-1.0, 'negation')

    // The arithmetic operators have the usual precedence levels.
    t.assertEq(1 + 2 * 3,  7, 'addition and multiplication')
    t.assertEq(10 - 2 * 3, 4, 'subtraction and multiplication')
    t.assertEq(1 + 15 / 3, 6, 'addition and division')
    t.assertEq(1 + 8 mod 3,  3, 'addition and modulo')
    t.assertEq(-2 + 4, 2, 'leading negatives')

    // But, grouping with parenthesis will change order of evaluation, as you
    // would expected.
    t.assertEq((1 + 2) * 3,   9, 'addition grouped and multiplication')
    t.assertEq((10 - 2) * 3, 24, 'subtraction grouped and multiplication')

    // All relation operators evaluate to a boolean value.
    // The equal operator is a single =.
    t.assertEq(1 = 1,          true, 'int equality true')
    t.assertEq(1 = 2,         false, 'int equality false')
    t.assertEq(1.5 = 1.5,      true, 'float equality true')
    t.assertEq(1.5 = 2.0,     false, 'float equality false')
    t.assertEq(false = false,  true, 'bool equality true')
    t.assertEq(false = true , false, 'bool equality false')
    t.assertEq('hey' = 'hey',  true, 'string equality true')
    t.assertEq('hey' = 'HEY', false, 'string equality false')

    // = is a strict equality operator. There are no conversions done.
    t.assertEq(false = 0, false, 'false and zero are not equal')

    // null is equal to itself but not to other values.
    t.assert(null = null, 'null equals itself')
    t.assertEq(null = 0, false, 'null and zero are not equal')

    // <> is the inequality operator
    t.assertEq(1 <> 1,         false, 'int inequality false')
    t.assertEq(1 <> 2,          true, 'int inequality true')
    t.assertEq(1.5 <> 1.5,     false, 'float inequality false')
    t.assertEq(1.5 <> 2.0,      true, 'float inequality true')
    t.assertEq(false <> false, false, 'bool inequality false')
    t.assertEq(false <> true ,  true, 'bool inequality true')
    t.assertEq('hey' <> 'hey', false, 'string inequality false')
    t.assertEq('hey' <> 'HEY',  true, 'string inequality true')

    // <> is also a strict inequality operator. There are no conversions done.
    t.assertEq(false <> 0, true, 'false and zero are inequal')

    // = and <> are lower than arithmetic in precedence.
    t.assertEq(1  +  2 * 3 = 7, true, '= precedence')
    t.assertEq(1  +  2 * 3 <> 9, true, '<> precedence')

    // There are also the normal relational operators.  These only work for
    // number valued objects.
    t.assertEq(1 < 2,   true, 'Int less than #1')
    t.assertEq(2 < 2,  false, 'Int less than #2')
    t.assertEq(1 <= 2,  true, 'Int less than or equal #1')
    t.assertEq(2 <= 2,  true, 'Int less than or equal #2')
    t.assertEq(3 <= 2, false, 'Int less than or equal #3')
    t.assertEq(3 > 2,   true, 'Int greater than #1')
    t.assertEq(1 > 2,  false, 'Int greater than #2')
    t.assertEq(3 >= 2,  true, 'Int greater than or equal #1')
    t.assertEq(3 >= 3,  true, 'Int greater than or equal #2')
    t.assertEq(3 >= 4, false, 'Int greater than or equal #3')

    t.assertEq(1.5 < 2.0,   true, 'Float less than #1')
    t.assertEq(2.0 < 2.0,  false, 'Float less than #2')
    t.assertEq(1.5 <= 2.0,  true, 'Float less than or equal #1')
    t.assertEq(2.0 <= 2.0,  true, 'Float less than or equal #2')
    t.assertEq(3.0 <= 2.5, false, 'Float less than or equal #3')
    t.assertEq(3.0 > 2.5,   true, 'Float greater than #1')
    t.assertEq(1.5 > 2.0,  false, 'Float greater than #2')
    t.assertEq(3.0 >= 2.5,  true, 'Float greater than or equal #1')
    t.assertEq(3.5 >= 3.5,  true, 'Float greater than or equal #2')
    t.assertEq(3.5 >= 4.0, false, 'Float greater than or equal #3')

    t.assertEq(1 < 2.5,   true, 'Int left float right less than #1')
    t.assertEq(2 < 2.0,  false, 'Int left float right less than #2')
    t.assertEq(1 <= 2.0,  true, 'Int left float right less than or equal #1')
    t.assertEq(2 <= 2.0,  true, 'Int left float right less than or equal #2')
    t.assertEq(3 <= 2.5, false, 'Int left float right less than or equal #3')
    t.assertEq(3 > 2.5,   true, 'Int left float right greater than #1')
    t.assertEq(1 > 2.0,  false, 'Int left float right greater than #2')
    t.assertEq(3 >= 2.5,  true, 'Int left float right greater than or equal #1')
    t.assertEq(3 >= 3.0,  true, 'Int left float right greater than or equal #2')
    t.assertEq(3 >= 4.0, false, 'Int left float right greater than or equal #3')

    t.assertEq(1.5 < 2,   true, 'Float left int right less than #1')
    t.assertEq(2.0 < 2,  false, 'Float left int right less than #2')
    t.assertEq(1.5 <= 2,  true, 'Float left int right less than or equal #1')
    t.assertEq(2.0 <= 2,  true, 'Float left int right less than or equal #2')
    t.assertEq(3.0 <= 2, false, 'Float left int right less than or equal #3')
    t.assertEq(3.0 > 2,   true, 'Float left int right greater than #1')
    t.assertEq(1.5 > 2,  false, 'Float left int right greater than #2')
    t.assertEq(3.0 >= 2,  true, 'Float left int right greater than or equal #1')
    t.assertEq(3.0 >= 3,  true, 'Float left int right greater than or equal #2')
    t.assertEq(3.5 >= 4, false, 'Float left int right greater than or equal #3')

    // Relational operators have higher precedence over equality operators
    t.assert(1 <  2 = 2 >  1, 'Equal / relational precedence #1')
    t.assert(1 <= 2 = 2 >= 1, 'Equal / relational precedence #2')
    t.assert(2 >  1 = 1 <  2, 'Equal / relational precedence #3')
    t.assert(2 >= 1 = 1 <= 2, 'Equal / relational precedence #4')

    // The logical operators are 'and', 'or' and 'not'.
    t.assertEq(true  and true,  true,  'And #1')
    t.assertEq(true  and false, false, 'And #2')
    t.assertEq(false and true,  false, 'And #3')
    t.assertEq(false and false, false, 'And #4')

    t.assertEq(true  or true,  true,  'Or #1')
    t.assertEq(true  or false, true,  'Or #2')
    t.assertEq(false or true,  true,  'Or #3')
    t.assertEq(false or false, false, 'Or #4')

    t.assertEq(not true, false, 'Not #1')
    t.assertEq(not false, true, 'Not #2')
    t.assertEq(not false or true, true, 'Leading not')

    // Logical and has lower precedence than equality and inequality.
    t.assert(1 <> 2 and 2 = 2, 'and precedence #1')
    t.assert(2 = 2 and 1 <> 2, 'and precedence #2')

    // 'or' is lower in precedence than 'and'.
    t.assertEq(true or false and false, true, 'or precedence #1')
    t.assertEq((true or false) and false, false, 'or precedence #1')

    // All values have a truth value.  false and null are false, everything else
    // is considered true.
    t.assertEq(not null, true, 'Null considered false #1')
    t.assertEq(null or true, true, 'Null considered false #2')
    t.assertEq(null and true, false, 'Null considered false #3')
    t.assertEq(not 1, false, 'Objects considered true.')
end

///////////////////////////////////////////////////////////////////////////////
// Variables Blocks
///////////////////////////////////////////////////////////////////////////////

var testVariablesAndBlocks := function (t) begin

    // Variables are declared with the keyword "var" and the assignment operator:
    // ":=".  A variable must be declared before it is used or else there will be
    // a runtime error.
    //
    // Identifiers must start with a letter and after that letters or digits
    // are valid.
    var x := 123
    t.assertEq(x, 123, 'variable declaration')
  
    // A variable may be updated with the assignment operator.
    x := x + 1
    t.assertEq(x, 124, 'variable assignment')
  
    // Assignments are an expression that return the value assigned to the
    // variable.
    t.assertEq(x := 2 * x, 248, 'assignment expression value')

    //
    // 'begin' and 'end delimit a block.  Within a block multiple expressions can
    // be listed.  Each expression is evaluated in the order they are found.  All
    // expression values are ignored, except the last one.  The last expression
    // is the result of the the last expression.  The ignored expressions usually
    // will be useful for their side effects.
    //
    // Crisp has no token to mark the end of an expression, not even new lines.
    // An expression ends when the next token can't be connected with the
    // current expression.  In the example below we have the expression 5*6 with
    // the next token 2.  Since 2 is not a token that can be used to extend the
    // 5*6 expression, the expression parsing stops.  For the last expression a
    // similar things happens with the end token.  It can't be used to continue
    // the 1+2 expression.
    //
    t.assertEq( begin 5*6  1+2 end , 3, 'Block expression return value')
  
    // Blocks can contain one expression.
    t.assertEq( begin 2+3 end, 5, 'Single expression block.')
  
    // Empty blocks do nothing but return null.
    t.assertEq( begin end , null, 'Empty block')
  
    // blocks also introduce a new scope for variable declarations.  You can 
    // "shadow" variables in outer scopes.
    begin
        var y := 100
        var x := 2 * y
        t.assertEq(y, 100, 'block variable')
        t.assertEq(x, 200, 'block variable shadowing')
    end
    t.assertEq(x, 248, 'variable unshadowed')
end

// Variables declared in the top scope are global variables.
var globalVar := 1234

var testGlobalVariables := function (t) begin
    var localVar := 4321
    t.assertEq(globalVar + localVar, 5555, 'global variable')
end

///////////////////////////////////////////////////////////////////////////////
// Branching
///////////////////////////////////////////////////////////////////////////////

var testBranching := function (t) begin
    // The usual if / else is present.  The syntax is
    //     if <condition> then <consequent> (else <alternative>)?
    //
    // The <condition> expression is evaluated, and if it is truthy -- that is
    // if it is not false and not null -- then the consequent is evaluated.
    // Otherwise the alternative is evaluated, if it exists.  If the
    // alternative wasn't given then it defaults to null.

    // ifs are expressions.
    t.assertEq(if true then 123, 123, 'If true expression')

    // If there is no else and the condition expression is falsy, then the
    // result is null.
    t.assertEq(if false then 123, null, 'If false expression')

    // If there is an else, and the condition expression is falsy, then the
    // result is the alternative expression.
    t.assertEq(if false then 123 else 321, 321, 'If / else false expression')

    // Any valid expression can go in the condition, consequent, and
    // alternative.
    t.assertEq(
        if begin var result := 1 + 2  result = 3 end then begin
            var x := 4
            var y := 2
            x*y
        end else
            'this will not be the result',
        8,
        'If / else expressions')

    // Since null is treated as false, you can check for null variables with if
    begin
        var x := null
        var message := 'using if to test for null'
        if x then
            t.fail(message)
        else
            t.pass(message)
    end

    // You can do if else chains
    begin
        var name := 'Tom'
        t.assertEq(
            if name = 'Jerry' then 1
            else if name = 'Susan' then 2
            else if name = 'Tom' then 3
            else 0,
            3,
            'if else chains')
    end
end

///////////////////////////////////////////////////////////////////////////////
// Looping
///////////////////////////////////////////////////////////////////////////////

var testLooping := function (t) begin

    // The usual while loop is present.  The syntax is
    //     while <condition> do <block>
    // 
    // Repeatedly evaluates the block expression as while the condition
    // expression is truthy.  Like if / else, condition and body can be any
    // valid kind of expression.
    // 
    begin
        var sum := 0
        var n := 1
        while n <= 100 do begin
            sum := sum + n
            n := n + 1
        end
        t.assertEq(sum, 5050, 'While loop')
    end


    // As usual while loops can fail to run at all.
    begin
        var n := 100
        while false do
            n := n + 1
        t.assertEq(n, 100, 'Never executing while loop')
    end

    // A while always evaluates to null.
    t.assertEq(while false do 0, null, 'While evals to null')

    // While expressions 
end

///////////////////////////////////////////////////////////////////////////////
// Scopes in if/else and while expressions.
///////////////////////////////////////////////////////////////////////////////
var testifElseWhileScopes := function (t) begin

    // If consequence and else alternative expression introduce a new scope
    // even if a block isn't used.
    var x := 1
    
    if true then
        var x := 100
    t.assertEq(x, 1, 'If consequence scoping')
    
    if false then
        var x := 1000
    else
        var x := 2000
    t.assertEq(x, 1, 'Else alternative scoping')



    // While body expression introduce a new scope even if a block isn't used.
    var toggle := {
        state := true
        
        getState := function () begin
            var result := self.state
            self.state := not self.state
            result
        end
    }
    var y := 1
    while toggle.getState() do
        var y := 100
    t.assertEq(y, 1, 'While body scoping')
end

///////////////////////////////////////////////////////////////////////////////
// Functions
///////////////////////////////////////////////////////////////////////////////

// The syntax for a function definition is
//   function (<comma separated parameters>) <body>
// The value of the function is value of the body.  As is usual, () is the
// "invocation" operator.  Functions must be assigned to a variable if you want
// to call them.

var nothing := function () begin end

// Single expression functions don't need a block.
var square := function (x) x * x

var divides := function (m, n) begin
    var remainder := n mod m
    remainder = 0
end

var factorial := function (n) begin
    if n = 1 then 1
    else n * factorial(n - 1)
end

var testFunctions := function (t) begin
    t.assertEq(nothing(), null, 'Empty function')
    t.assertEq(square(3), 9, 'Function declaration')
    t.assertEq(divides(5, 35), true, 'Named functions')
    t.assertEq(factorial(10), 3628800, 'Recursive functions')
end

///////////////////////////////////////////////////////////////////////////////
// More Logical
///////////////////////////////////////////////////////////////////////////////

var testLogicalAndOr := function (t) begin
    var counter := {
        n := 0
        get := function () self.n := self.n + 1
    }

    // The 'and' operator short circuits in the expected way.
    t.assertEq(false and counter.get() = 1, false, 'and short circuits #1')
    t.assertEq(counter.get(), 1, 'and short circuits #2')
    t.assertEq(true and counter.get() = 2, true, 'and short circuits #3')
    t.assertEq(counter.get(), 3, 'and short circuits #4')

    // The 'or' operator short circuits in the expected way.
    counter.n := 0
    t.assertEq(true or counter.get() = 1, true, 'or short circuits #1')
    t.assertEq(counter.get(), 1, 'or short circuits #2')
    t.assertEq(false or counter.get() = 2, true, 'or short circuits #3')
    t.assertEq(counter.get(), 3, 'or short circuits #4')
end

///////////////////////////////////////////////////////////////////////////////
// Objects
///////////////////////////////////////////////////////////////////////////////

var testObjects := function (t) begin
    // New objects can be created with object literals.  Object literals are
    // a list of properties with the syntax <identifier> := <expression>.
    var empty := { }
    var person := {
        name := {
            first := 'John'
            last := 'Smith'
        }
        age := 40
    }

    // Object properties can be retrieved with the index operator.  The
    // property name must be passed in as a string.
    t.assertEq(person['age'], 40, 'Object indexing get #1')
    t.assertEq(person['name']['first'], 'John', 'Object indexing get #2')

    // Object properties can be updated and added using the index operator
    // and an assignment operator.
    person['weight'] := 250
    person['name']['middle'] := 'James'
    t.assertEq(person['weight'], 250, 'Object index set #1')
    t.assertEq(person['name']['middle'], 'James', 'Object index set #2')

    // If the object's key is a valid identfier then a property's value can
    // be got with a '.' operator.  It can also be set the same way.  This,
    // of course, is easier to use than the index operator.
    person.height := 5.5
    person.name.title := 'Dr.'
    t.assertEq(person.height, 5.5, 'Dot operator #1')
    t.assertEq(person.name.title, 'Dr.', 'Dot operator #2')

    // In fact the key to an object property can be any other object, but
    // then you're stuck with using the index operator.  That is objects
    // are maps / dictionaries / associative arrays.  You can also
    // add properties to objects other than user defined ones.
    person[false] := 2.5
    var f := function (x) 2 * x
    f.description := 'a function that doubles'
    t.assertEq(person[false], 2.5, 'Index operator bool key')
    t.assertEq(f.description, 'a function that doubles', 'Property on a function')
    t.assertEq(f(2), 4, 'Function call that has a property')

    // If a key isn't in an object, then retrieving it returns null.
    t.assertEq(person.gender, null, 'object key not set')
end

///////////////////////////////////////////////////////////////////////////////
// Code to manage running tests.
///////////////////////////////////////////////////////////////////////////////

var Test := {
    
    init := function () begin
        self.nTests := 0
        self.nErrors := 0
        self.showPassedTest := true
    end

    displaySummary := function () begin
        write('\n', self.nTests - self.nErrors, ' out of ', self.nTests, ' tests passed.\n')
        write('There are ', self.nErrors, ' errors. ')
        write(if self.nErrors = 0 then ':-)' else 'D-:', '\n')
    end

    pass := function (message) begin
        self.nTests := self.nTests + 1
        write('[OK] "', message, '"\n')
    end
    
    fail := function (message) begin
        self.nTests := self.nTests + 1
        self.nErrors := self.nErrors + 1
        write('[FAILED] "', message, '"\n')
    end

    assert := function (condition, message) begin
        if not condition then
            self.fail(message)
        else if self.showPassedTest then
            self.pass(message)
    end

    assertEq := function (actual, expected, message) begin
        self.nTests := self.nTests + 1
        if actual <> expected then begin
            write('[FAILED] "', message, '": expected <', expected, '> got <',
                actual, '>\n')
            self.nErrors := self.nErrors + 1
        end else if self.showPassedTest then
            write('[OK] "', message, '"\n')
    end
}

begin
    var test := beget Test
    test.init()

    testLiterals(test)
    testOperators(test)
    testVariablesAndBlocks(test)
    testGlobalVariables(test)
    testBranching(test)
    testLooping(test)
    testifElseWhileScopes(test)
    testFunctions(test)
    testLogicalAndOr(test)
    testObjects(test)

    test.displaySummary()
end