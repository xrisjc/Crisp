///////////////////////////////////////////////////////////////////////////////
// File: Test.crisp
// Purpose: Integration testing of Crisp functionality that also serves as a
// guide to Crips (for now).
///////////////////////////////////////////////////////////////////////////////

//
// As you might have guessed, // starts a comment.  As per usual, comments are
// ignored and end when a new line character is reached.
//
// All other whitespace is ignored, so your free to format code as you see
// fit.
//
// Oh, and one more thing before we begin, everthing is an expression.
// Everthing.  But expressions can have side effects, so it's not "pure"
// expressions.
//

///////////////////////////////////////////////////////////////////////////////
// Let's setup some code to help us do tests, and keep track of how many
// errors occur.
///////////////////////////////////////////////////////////////////////////////

let nTests := 0
let nErrors := 0

fn assert(condition, message)
  begin
    nTests := nTests + 1
    if condition then
        writeLn('[OK] ', message)
    else
      begin
        writeLn('[FAILED] ', message)
        nErrors := nErrors + 1
      end
  end

fn assertEq(test, expected, message)
  begin
    nTests := nTests + 1
    if test = expected then
        writeLn('[OK] ', message)
    else
      begin
        writeLn('[FAILED] ', message)
        writeLn('expected ', expected, ' got ', test)
        nErrors := nErrors + 1
      end
  end

fn displaySummary()
  begin
    writeLn()
    writeLn(nTests - nErrors, ' out of ', nTests, ' tests passed.')
    writeLn('There are ', nErrors, ' errors. ',
        if nErrors=0 then ':-)' else 'D-:')
  end


///////////////////////////////////////////////////////////////////////////////
// Basic Literals
///////////////////////////////////////////////////////////////////////////////

// Crisp has the literal expressions you would expect.

// Strings are delimited by single quotes. The are the .NET string type
// internally.
assertEq('hi', 'hi', 'string literal')

// Number values are double (64 bit floating point) internally.
assertEq(123, 123, 'int number literal')
assertEq(1., 1, 'floating point #1')
assertEq(1.5, 1.5, 'floating point #2')

// Boolean values are given by keywords true and false representing the
// obvious values.  The are represented by the bool type internally.
assert(true, 'true literal')
assertEq(false, false, 'false literal')

// The keyword null evaluates to the null object value, which is a singleton
// value that is not equal to any other value.
assertEq(null, null, 'null literal')


///////////////////////////////////////////////////////////////////////////////
// Arithmetic Operators
///////////////////////////////////////////////////////////////////////////////

// After literals, more complex expressions can be created with operators.

// Crisp has the usual arithmetic operators.
assertEq( 1 + 2,   3, 'addition'      )
assertEq( 5 - 2,   3, 'subtraction'   )
assertEq( 2 * 3,   6, 'multiplication')
assertEq(12 % 5,   2, 'modulo'        )
assertEq(15 / 5,   3, 'division #1'   )
assertEq( 1 / 2, 0.5, 'division #2'   )

// The arithmetic operators have the usual precedence levels.
assertEq(1  +  2 * 3, 7, 'addition and multiplication'    )
assertEq(10 -  2 * 3, 4, 'subtraction and multiplication' )
assertEq(1  + 15 / 3, 6, 'addition and division'          )
assertEq(1  +  8 % 3, 3, 'addition and modulo'            )

// But, grouping with parenthesis will change order of evaluation, as you
// would expected.
assertEq((1  + 2) * 3,  9, 'addition grouped and multiplication'    )
assertEq((10 - 2) * 3, 24, 'subtraction grouped and multiplication' )

///////////////////////////////////////////////////////////////////////////////
// String Operators
///////////////////////////////////////////////////////////////////////////////

// + also concats strings
assertEq('first ' + 'second', 'first second', 'string concat')

// string also can be indexed (zero-based).
assertEq('first'[1], 'i', 'string indexing')

///////////////////////////////////////////////////////////////////////////////
// Equality, Inequality, Relational, and Logical
///////////////////////////////////////////////////////////////////////////////

// All relation operators evaluate to a boolean value.

// The equal operator is a single =.
assertEq(    1 = 1    , true  , 'number equality true')
assertEq(    1 = 2    , false , 'number equality false')
assertEq(false = false, true  , 'bool equality true')
assertEq(false = true , false , 'bool equality false')
assertEq('hey' = 'hey', true  , 'string equality true')
assertEq('hey' = 'HEY', false , 'string equality false')

// = is a strict equality operator. There are no conversions done.
assertEq(false = 0, false, 'false and zero are not equal')

// null is equal to itself but not to other values.
assert(null = null, 'null equals itself')
assertEq(null = 0, false, 'null and zero are not equal')

// <> is the inequality operator
assertEq(    1 <> 1    , false , 'number inequality false')
assertEq(    1 <> 2    , true  , 'number inequality true')
assertEq(false <> false, false , 'bool inequality false')
assertEq(false <> true , true  , 'bool inequality true')
assertEq('hey' <> 'hey', false , 'string inequality false')
assertEq('hey' <> 'HEY', true  , 'string inequality true')

// <> is also a strict inequality operator. There are no conversions done.
assertEq(false <> 0, true, 'false and zero are inequal')

// = and <> are lower than arithmatic in precedence.
assertEq(1  +  2 * 3 = 7, true, '= precedence')
assertEq(1  +  2 * 3 <> 9, true, '<> precedence')

// there are also the normal relational operators. These only work for
// number valued objects.
assert(1 < 2, 'Less than #1')
assertEq(2 < 2, false, 'Less than #2')
assert(1 <= 2, 'Less than or equal #1')
assert(2 <= 2, 'Less than or equal #2')
assertEq(3 <= 2, false, 'Less than or equal #3')
assert(3 > 2,  'Greater than #1')
assertEq(1 > 2, false, 'Greater than #2')
assert(3 >= 2, 'Greater than or equal #1')
assert(3 >= 3, 'Greater than or equal #2')
assertEq(3 >= 4, false, 'Greater than or equal #3')

// Relational operators have higher precedence over equality operators
assert(1 <  2 = 2 >  1, 'Equal / relational precedence #1')
assert(1 <= 2 = 2 >= 1, 'Equal / relational precedence #2')
assert(2 >  1 = 1 <  2, 'Equal / relational precedence #3')
assert(2 >= 1 = 1 <= 2, 'Equal / relational precedence #4')

// The logical operators are 'and' and 'or'.
assertEq(true  and true,  true,  'And #1')
assertEq(true  and false, false, 'And #2')
assertEq(false and true,  false, 'And #3')
assertEq(false and false, false, 'And #4')

assertEq(true  or true,  true,  'Or #1')
assertEq(true  or false, true,  'Or #2')
assertEq(false or true,  true,  'Or #3')
assertEq(false or false, false, 'Or #4')

// Logical and has lower precedence than equality and inequality.
assert(1 <> 2 and 2 = 2, 'and precedence #1')
assert(2 = 2 and 1 <> 2, 'and precedence #2')

// 'or' is lower in precedence than 'and'.
assertEq(true or false and false, true, 'or precedence #1')
assertEq((true or false) and false, false, 'or precedence #1')

///////////////////////////////////////////////////////////////////////////////
// Variables Blocks
///////////////////////////////////////////////////////////////////////////////

// Variables are declared with the keyword "let" and the assignment operator:
// ":=".  A variable must be declared before it is used or else there will be
// a runtime error.
//
// Right now variable identifiers can only be upper or lower case letters.

let x := 123
assertEq(x, 123, 'variable declaration')
// TODO: Add test for runtime error.

// A variable may be updated with the assignment operator.
x := x + 1
assertEq(x, 124, 'variable assignment')

// Assignments are an expression that return the value assinged to the
// variable.
assertEq(x := 2 * x, 248, 'assignment expression value')

//
// begin and end delimit a block.  Within a block mulitple expressions can
// be listed.  Each expression is evaluated in the order they are found.  All
// expression values are ignored, except the last one.  The last expression
// is the result of the the last expression.  The ignored expressions usually
// will be useful for their side effects.
//
// Crisp has no token to mark the end of an expression, not even new lines.
// An expression ends when the next token can't be connected with the
// current expression.  In the example below we have the expression 5*6 with
// the next token 2.  Since 2 is not a token that can be used to extend the
// 5*6 expression, the expression parsing stops.  For the last expression a
// similar things happens with the end token.  It can't be used to continue
// the 1+2 expression.
//
assertEq( begin 5*6  1+2 end , 3, 'Block expression return value')

// Blocks can contain one expression.
assertEq( begin 2+3 end, 5, 'Single expression block.')

// Empty blocks do nothing but return null.
assertEq( begin end , null, 'Empty block')

// blocks also introduce a new scope for variable declarations.  You can 
// "shadow" variables in outer scopes.
begin
    let y := 100
    let x := 2 * y
    assertEq(y, 100, 'block variable')
    assertEq(x, 200, 'block variable shadowing')
end
assertEq(x, 248, 'variable unshadowed')
// TODO: Test that y is undefined here.

///////////////////////////////////////////////////////////////////////////////
// Branching
///////////////////////////////////////////////////////////////////////////////

// The usual if / else is present.  The syntax is either
//     if <condition> then <consequent>
// or
//     if <condition> then <consequent> else <alternative>
//
// The <condtion> expresion *must* be a Boolean value or else there will be a
// runtime exception.

// if / else can be used as an expression.  
assertEq(if true then 123, 123, 'If true expression')

// If there is no else and the condition expression is false, then the result
// is null.
assertEq(if false then 123, null, 'If false expression')

// If there is an else, and the condition expression is false, then the result
// is the alternative expression.
assertEq(if false then 123 else 321, 321, 'If / else false expression')

// Any valid expression can go in the condition, consequent, and alternative.
assertEq(
    if begin let result:=1+2  result=3 end then
        begin let x:=4 let y:=2  x*y end 
    else
       'this will not be the result',
    8,
    'If / else expressions')


///////////////////////////////////////////////////////////////////////////////
// Looping
///////////////////////////////////////////////////////////////////////////////

// The ususal while loop is present.  The syntax is
//     while <condition> do <body>
// 
// The <condtion> expresion *must* be a Boolean value or else there will be a
// runtime exception.  Like if / else, condition and body can be any valid
// kind of expression.
// 
begin
    let sum := 0
    let n := 1
    while n <= 100 do
      begin
        sum := sum + n
        n := n + 1
      end
    assertEq(sum, 5050, 'While loop')
end


// As usual while loops can fail to run at all.
begin
    let n := 100
    while false do
        n := n + 1
    assertEq(n, 100, 'Never executing while loop')
end

// A while always evaluates to null.
assertEq(while false do 0, null, 'While evals to null')

///////////////////////////////////////////////////////////////////////////////
// Functions
///////////////////////////////////////////////////////////////////////////////

// The syntax for a function "literal" is
//   fn (<comma seperated parameters>) <body>
//
// () is the "invocation" operator. The returns values is the result of the
// body expression, which can be any valid expression including a block.


// Functions are values and can be anonymous and immediately invoked.
assertEq( (fn (x, y) x*y)(100, 200), 20000, 'Inline function' )

// Since functions are values they can be assigned to variables and invoked
// with ().
let square := fn (x) x * x
assertEq(square(3), 9, 'Function assigned to variable')

// A syntactic shortcut for assigning to a variable is to just put the variable
// name between fn and the parameters
fn divides(m, n)
  begin
    let remainder := n % m
    remainder = 0
  end
assertEq(divides(5, 35), true, 'Named functions')

// Functions are also closures.  Here's the standard counter function example.
fn makeCounter()
  begin
    let x := 0
    fn ()
      begin
        x := x + 1
        x
      end
  end
let counter := makeCounter()
assertEq(begin counter() counter() counter() end, 3, 'Functions with closures')

///////////////////////////////////////////////////////////////////////////////
// More Logical
///////////////////////////////////////////////////////////////////////////////

// The 'and' operator short circuits in the expected way.
counter := makeCounter()
assertEq(false and counter() = 1, false, 'and short circuits #1')
assertEq(counter(), 1, 'and short circuits #2')
assertEq(true and counter() = 2, true, 'and short circuits #3')
assertEq(counter(), 3, 'and short circuits #4')

// The 'or' operator short circuits in the expected way.
counter := makeCounter()
assertEq(true or counter() = 1, true, 'or short circuits #1')
assertEq(counter(), 1, 'or short circuits #2')
assertEq(false or counter() = 2, true, 'or short circuits #3')
assertEq(counter(), 3, 'or short circuits #4')

///////////////////////////////////////////////////////////////////////////////
// Maps
///////////////////////////////////////////////////////////////////////////////

// Maps are constructed with { and }. { } is an empty map.  [ and ] are used
// to index the map in the usual ways to assign a value to a key and get the
// value for a key.
begin
    let map := { }
    map['year'] := 2018
    map[90 * 100] := 'number that it is over'
    assertEq(map['year'  ], 2018,                     'map get / set value #1')
    assertEq(map[9 * 1000], 'number that it is over', 'map get / set value #2')
end

// You can also initilize a maps as shown below
begin
    let map :=
    {
        ['name'] = 'Chris',
        ['sign'] = 'Cancer',
        ['age'] = 37
    }
    assertEq(map['name'], 'Chris',  'map get / set value #3')
    assertEq(map['sign'], 'Cancer', 'map get / set value #4')
    assertEq(map['age'],   37,      'map get / set value #5')
end

///////////////////////////////////////////////////////////////////////////////
// The End
///////////////////////////////////////////////////////////////////////////////

displaySummary()

