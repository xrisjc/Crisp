///////////////////////////////////////////////////////////////////////////////
// File: Test.crisp
// Purpose: Integration testing of Crisp functionality that also serves as a
// guide to Crips (for now).
///////////////////////////////////////////////////////////////////////////////

//
// As you might have guessed, // starts a comment.  As per usual, comments are
// ignored and end when a new line character is reached.
//
// All other whitespace is ignored, so your free to format code as you see
// fit.
//
// Oh, and one more thing before we begin, everthing is an expression.
// Everthing.  But expressions can have side effects, so it's not "pure"
// expressions.
//

///////////////////////////////////////////////////////////////////////////////
// Let's setup some code to help us do tests, and keep track of how many
// errors occur.
///////////////////////////////////////////////////////////////////////////////

let nTests := 0
let nErrors := 0

fn assert(condition, message) {
    nTests := nTests + 1
    if condition {
        writeLn('[OK] ', message)
    } else { 
        writeLn('[FAILED] ', message)
        nErrors := nErrors + 1
    }
}

fn assertEq(test, expected, message) {
    nTests := nTests + 1
    if (test = expected) {
        writeLn('[OK] ', message)
    } else {
        writeLn('[FAILED] ', message)
        writeLn('expected ', expected, ' got ', test)
        nErrors := nErrors + 1
    }
}

fn displaySummary() {
    writeLn()
    writeLn(nTests - nErrors, ' out of ', nTests, ' tests passed.')
    writeLn('There are ', nErrors, ' errors. ', if nErrors=0 ':-)' else 'D-:')
}


///////////////////////////////////////////////////////////////////////////////
// Basic Literals
///////////////////////////////////////////////////////////////////////////////

// Crisp has the literal expressions you would expect.

// Strings are delimited by single quotes. The are the .NET string type
// internally.
assertEq('hi', 'hi', 'string literal')

// Number values are double (64 bit floating point) internally.
assertEq(123, 123, 'int number literal')

// Boolean values are given by keywords true and false representing the
// obvious values.  The are represented by the bool type internally.
assert(true, 'true literal')
assertEq(false, false, 'false literal')

// The keyword null evaluates to the null object value, which is a singleton
// value that is not equal to any other value.
assertEq(null, null, 'null literal')


///////////////////////////////////////////////////////////////////////////////
// Arithmetic Operators
///////////////////////////////////////////////////////////////////////////////

// After literals, more complex expressions can be created with operators.

// Crisp has the usual arithmetic operators.
assertEq( 1 + 2, 3, 'addition'      )
assertEq( 5 - 2, 3, 'subtraction'   )
assertEq( 2 * 3, 6, 'multiplication')
assertEq(12 % 5, 2, 'modulo'        )
assertEq(15 / 5, 3, 'division'      )

// The arithmetic operators have the usual precedence levels.
assertEq(1  +  2 * 3, 7, 'addition and multiplication'    )
assertEq(10 -  2 * 3, 4, 'subtraction and multiplication' )
assertEq(1  + 15 / 3, 6, 'addition and division'          )
assertEq(1  +  8 % 3, 3, 'addition and modulo'            )

// But, grouping with parenthesis will change order of evaluation, as you
// would expected.
assertEq((1  + 2) * 3,  9, 'addition grouped and multiplication'    )
assertEq((10 - 2) * 3, 24, 'subtraction grouped and multiplication' )


///////////////////////////////////////////////////////////////////////////////
// Relationl Operators
///////////////////////////////////////////////////////////////////////////////

// All relation operators evaluate to a boolean value.

// The equal operator is a single = 
assertEq(    1 = 1    , true  , 'number equality true')
assertEq(    1 = 2    , false , 'number equality false')
assertEq(false = false, true  , 'bool equality true')
assertEq(false = true , false , 'bool equality false')

// = is a strict equality operator. There are no conversions done.
assertEq(false = 0, false, 'false and zero are not equal')

// null is equal to itself but not to other values.
assert(null = null, 'null equals itself')
assertEq(null = 0, false, 'null and zero are not equal')


///////////////////////////////////////////////////////////////////////////////
// Blocks and Variables
///////////////////////////////////////////////////////////////////////////////

//
// { and } delimit a block.  Within a block mulitple expressions can be 
// listed.  Each expression is evaluated in the order they are found.  All
// expression values are ignored, except the last one.  The last expression
// is the result of the the last expression.  The ignored expressions usually
// will be useful for their side effects.
//
// Crisp has no token to mark the end of an expression, not even new lines.
// An expression ends when the next token can't be connected with the
// current expression.  In the example below we have the expression 5*6 with
// the next token 2.  Since 2 is not a token that can be used to extend the
// 5*6 expression, the expression parsing stops.  For the last expression a
// similar things happens with the } token.  It can't be used to continue the
// 1+2 expression.
//
assertEq( { 5*6  1+2 } , 3, 'Block expression return value')

// Blocks can contain one expression.
assertEq( { 2+3 }, 5, 'Single expression block.')

// Empty blocks do nothing but return null.
assertEq( { } , null, 'Empty block')




{
    let x := 123
    assertEq(x, 123, 'variable binding')
    {
        let x := 321
        assertEq(x, 321, 'inner block shadowing')
    }
    assertEq(x, 123, 'variable unshadowed')
    x := x + 2
    assertEq(x, 125, 'assignment expression')
    assertEq(x := x + 2, 127, 'assignment expression result')
    assertEq(x, 127, 'assignment expression result saved')
}
{
    let blockResult := {
        let first := 123
        2 * first
    }
    assertEq(blockResult, 246, 'block expression')
}
assertEq(( fn (x) 2*x )(123), 246, 'anonymous function call')
{
    let square := fn (x) { x * x }
    assertEq(square(3), 9, 'anonymous function in let')
    fn triple(x) { x * x * x }
    assertEq(triple(3), 27, 'named function')
}
{
    let n := 100
    fn makeCounter() {
        let n := 0
        fn () { n := n + 1 }
    }
    let counter := makeCounter()
    counter()
    counter()
    assertEq(counter(), 3, 'function closure')
    assertEq(n, 100, 'function closure shadowing')
}
assertEq(if true 123, 123, 'if expression only true')
assertEq(if false 123, null, 'if expression only true alt')
assertEq(if true 123 else 321, 123, 'if else expression')
assertEq(if false 123 else 321, 321, 'if else expression alt')
{
    let sum := 0
    let whileResult := while false { sum := sum + 1 }
    assertEq(sum, 0, 'while not executed')
    assertEq(whileResult, null, 'while not executed result')
    let n := 1
    whileResult := while n = 101 = false {
        sum := sum + n
        n := n + 1
    }
    assertEq(sum, 5050, 'while loop accumulating')
    assertEq(whileResult, null, 'while loop accumulating result')
}

displaySummary()

